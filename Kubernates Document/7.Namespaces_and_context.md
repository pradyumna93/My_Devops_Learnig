# 🧭 Topic 3 — Namespaces and Contexts (In-Depth Theory)

---

## 🌍 1️⃣ What Are Namespaces in Kubernetes?

A **Namespace** in Kubernetes is a *logical partition* of the cluster — a way to divide cluster resources among multiple users, teams, or applications.

Think of it like **separate compartments** or **virtual clusters** within the same physical cluster.

---

### 💡 Example Analogy

Imagine a single office building (the **cluster**) that contains:

* Marketing department
* Finance department
* Engineering department

Each department has its own workspace, policies, and resources — but they’re all under one company (the cluster).

That’s exactly what **Namespaces** do in Kubernetes.

---

## 🧩 2️⃣ Why Do We Need Namespaces?

Namespaces are used for:

1. **Resource isolation**

   * Prevent conflicts between teams/applications.
   * Example: Two teams can each have a “frontend” pod, but in different namespaces.

2. **Access control**

   * Different users can have different RBAC permissions in each namespace.

3. **Resource quota management**

   * Limit CPU, memory, or object count per namespace.

4. **Environment separation**

   * You can use namespaces to create logical environments like:

     * `dev`
     * `staging`
     * `production`

---

## ⚙️ 3️⃣ Default Namespaces in a Cluster

When you install Kubernetes, some namespaces are automatically created.

| Namespace           | Purpose                                                                    |
| ------------------- | -------------------------------------------------------------------------- |
| **default**         | Used for objects without a specified namespace                             |
| **kube-system**     | Used for system components (like kube-dns, API server, controller-manager) |
| **kube-public**     | Readable by all users, used for publicly available resources               |
| **kube-node-lease** | Stores node heartbeat data for node availability checks                    |

You can verify them:

```bash
kubectl get namespaces
```

---

## 🧱 4️⃣ Creating Your Own Namespace

You can create a namespace in two ways:

### a) Using kubectl command:

```bash
kubectl create namespace dev
```

### b) Using a YAML manifest:

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: dev
```

Apply it:

```bash
kubectl apply -f namespace.yaml
```

---

## 🔍 5️⃣ Using Namespaces

### 🧩 View All Namespaces:

```bash
kubectl get namespaces
```

### 🧩 View Resources in a Specific Namespace:

```bash
kubectl get pods -n dev
```

### 🧩 Create a Pod in a Specific Namespace:

```bash
kubectl run nginx --image=nginx -n dev
```

### 🧩 Switch Default Namespace for a Command:

```bash
kubectl get pods --namespace=production
```

If you don’t specify `-n`, Kubernetes assumes the **default** namespace.

---

## 🧰 6️⃣ Resource Names and Uniqueness

Within one namespace:

* All object names (Pods, Services, ConfigMaps, etc.) must be **unique**.

Between namespaces:

* The same object name can exist in multiple namespaces.

✅ Example:

```
Pod “nginx” in namespace “dev”
Pod “nginx” in namespace “prod”
```

→ Both are valid because they’re in different namespaces.

---

## 🧮 7️⃣ Resource Quotas in Namespaces

You can restrict resource usage per namespace using **ResourceQuota**.

Example:

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: compute-quota
  namespace: dev
spec:
  hard:
    pods: "10"
    requests.cpu: "2"
    requests.memory: 4Gi
    limits.cpu: "4"
    limits.memory: 8Gi
```

This ensures the `dev` namespace can’t use more than its allocated share of resources.

---

## 🧱 8️⃣ LimitRange (Per Pod/Container Resource Limit)

Inside a namespace, you can also define **LimitRange** —
to automatically enforce default CPU/memory limits for each pod or container.

Example:

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: cpu-limit-range
  namespace: dev
spec:
  limits:
  - default:
      cpu: 500m
      memory: 256Mi
    defaultRequest:
      cpu: 200m
      memory: 128Mi
    type: Container
```

This prevents one container from consuming all node resources.

---

## 🔐 9️⃣ Namespaces and RBAC (Access Control)

Namespaces are key to implementing **Role-Based Access Control (RBAC)**.

You can:

* Grant specific users or groups access to specific namespaces.
* Isolate permissions between teams.

Example:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: dev
  name: dev-role
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "watch", "list"]
```

Then bind it with a RoleBinding to a specific user.

---

## 💬 10️⃣ Viewing Resources Across All Namespaces

To see all resources in every namespace:

```bash
kubectl get pods --all-namespaces
```

To view other objects (services, deployments, etc.):

```bash
kubectl get all --all-namespaces
```

---

## 🧠 Summary of Namespaces

| Feature                | Description                                        |
| ---------------------- | -------------------------------------------------- |
| **Purpose**            | Logical separation of resources                    |
| **Scope**              | Cluster-wide                                       |
| **Benefits**           | Isolation, access control, quotas                  |
| **Default Namespaces** | default, kube-system, kube-public, kube-node-lease |
| **Common Uses**        | Dev/Prod isolation, multi-team environments        |

---

## ⚙️ 11️⃣ What Are Contexts?

Namespaces define *where* resources live.
**Contexts** define *which cluster, user, and namespace* you’re currently working in.

A **context** is part of your **kubeconfig file** (`~/.kube/config`).

---

### 📄 kubeconfig Structure Example

```yaml
apiVersion: v1
clusters:
- cluster:
    server: https://192.168.49.2:8443
  name: dev-cluster
contexts:
- context:
    cluster: dev-cluster
    user: dev-user
    namespace: dev
  name: dev-context
current-context: dev-context
kind: Config
preferences: {}
users:
- name: dev-user
  user:
    client-certificate: /path/dev.crt
    client-key: /path/dev.key
```

---

### 🔹 Key Elements

| Field               | Meaning                                |
| ------------------- | -------------------------------------- |
| **Cluster**         | Which Kubernetes cluster to connect to |
| **User**            | Which credentials to use               |
| **Namespace**       | Default namespace for this context     |
| **Context**         | Combines cluster + user + namespace    |
| **current-context** | The context currently active           |

---

## 🧭 12️⃣ Managing Contexts

### List all contexts:

```bash
kubectl config get-contexts
```

### View the current context:

```bash
kubectl config current-context
```

### Switch to another context:

```bash
kubectl config use-context dev-context
```

### Set a default namespace for a context:

```bash
kubectl config set-context --current --namespace=dev
```

Now all commands (like `kubectl get pods`) default to the `dev` namespace.

---

## 💡 13️⃣ Multi-Cluster & Multi-User Environments

Contexts are especially useful when:

* You manage **multiple clusters** (e.g., dev, staging, prod).
* You have **different credentials** for each cluster.
* You want to quickly switch between clusters or namespaces without retyping `--namespace` or `--server`.

---

## 🧠 14️⃣ Namespaces vs. Contexts — Difference

| Feature        | **Namespace**                      | **Context**                                                        |
| -------------- | ---------------------------------- | ------------------------------------------------------------------ |
| **Definition** | Logical partition inside a cluster | Configuration in kubeconfig combining cluster, user, and namespace |
| **Scope**      | Cluster-level                      | User’s kubeconfig-level                                            |
| **Purpose**    | Isolate workloads and resources    | Easily switch between clusters and namespaces                      |
| **Example**    | `kubectl get pods -n dev`          | `kubectl config use-context dev-context`                           |

---

## 🧩 Visualization — Cluster with Multiple Namespaces and Contexts

```
Kubernetes Cluster
│
├── Namespace: dev
│   ├── Pod: frontend
│   ├── Pod: backend
│   └── Service: dev-service
│
├── Namespace: prod
│   ├── Pod: frontend
│   ├── Pod: backend
│   └── Service: prod-service
│
└── Namespace: monitoring
    ├── Pod: prometheus
    └── Pod: grafana
```

Contexts in your kubeconfig might look like:

* `dev-context` → Cluster + dev namespace
* `prod-context` → Cluster + prod namespace
* `monitoring-context` → Cluster + monitoring namespace

---

## 🧾 15️⃣ Real-World Example

**Scenario:**
You’re managing two environments — Dev and Prod — in the same cluster.

### Step 1: Create namespaces

```bash
kubectl create namespace dev
kubectl create namespace prod
```

### Step 2: Create contexts

```bash
kubectl config set-context dev-context --cluster=kubernetes --user=admin --namespace=dev
kubectl config set-context prod-context --cluster=kubernetes --user=admin --namespace=prod
```

### Step 3: Switch between environments

```bash
kubectl config use-context dev-context
# Work on dev

kubectl config use-context prod-context
# Work on prod
```

Easy switching = fewer mistakes 🚀

---

## ✅ Summary

| Concept                | Description                                           |
| ---------------------- | ----------------------------------------------------- |
| **Namespace**          | Logical partition in a cluster for resource isolation |
| **Purpose**            | Separate environments, manage resources, apply quotas |
| **Default Namespaces** | default, kube-system, kube-public, kube-node-lease    |
| **Context**            | Configuration combining cluster + user + namespace    |
| **Purpose**            | Simplifies working with multiple clusters/namespaces  |
| **Key Command**        | `kubectl config use-context`                          |

---

Namespaces organize **what** you manage inside the cluster.
Contexts organize **where and as whom** you manage it from outside.

---