# ğŸ§­ Topic 3 â€” Namespaces and Contexts (In-Depth Theory)

---

## ğŸŒ 1ï¸âƒ£ What Are Namespaces in Kubernetes?

A **Namespace** in Kubernetes is a *logical partition* of the cluster â€” a way to divide cluster resources among multiple users, teams, or applications.

Think of it like **separate compartments** or **virtual clusters** within the same physical cluster.

---

### ğŸ’¡ Example Analogy

Imagine a single office building (the **cluster**) that contains:

* Marketing department
* Finance department
* Engineering department

Each department has its own workspace, policies, and resources â€” but theyâ€™re all under one company (the cluster).

Thatâ€™s exactly what **Namespaces** do in Kubernetes.

---

## ğŸ§© 2ï¸âƒ£ Why Do We Need Namespaces?

Namespaces are used for:

1. **Resource isolation**

   * Prevent conflicts between teams/applications.
   * Example: Two teams can each have a â€œfrontendâ€ pod, but in different namespaces.

2. **Access control**

   * Different users can have different RBAC permissions in each namespace.

3. **Resource quota management**

   * Limit CPU, memory, or object count per namespace.

4. **Environment separation**

   * You can use namespaces to create logical environments like:

     * `dev`
     * `staging`
     * `production`

---

## âš™ï¸ 3ï¸âƒ£ Default Namespaces in a Cluster

When you install Kubernetes, some namespaces are automatically created.

| Namespace           | Purpose                                                                    |
| ------------------- | -------------------------------------------------------------------------- |
| **default**         | Used for objects without a specified namespace                             |
| **kube-system**     | Used for system components (like kube-dns, API server, controller-manager) |
| **kube-public**     | Readable by all users, used for publicly available resources               |
| **kube-node-lease** | Stores node heartbeat data for node availability checks                    |

You can verify them:

```bash
kubectl get namespaces
```

---

## ğŸ§± 4ï¸âƒ£ Creating Your Own Namespace

You can create a namespace in two ways:

### a) Using kubectl command:

```bash
kubectl create namespace dev
```

### b) Using a YAML manifest:

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: dev
```

Apply it:

```bash
kubectl apply -f namespace.yaml
```

---

## ğŸ” 5ï¸âƒ£ Using Namespaces

### ğŸ§© View All Namespaces:

```bash
kubectl get namespaces
```

### ğŸ§© View Resources in a Specific Namespace:

```bash
kubectl get pods -n dev
```

### ğŸ§© Create a Pod in a Specific Namespace:

```bash
kubectl run nginx --image=nginx -n dev
```

### ğŸ§© Switch Default Namespace for a Command:

```bash
kubectl get pods --namespace=production
```

If you donâ€™t specify `-n`, Kubernetes assumes the **default** namespace.

---

## ğŸ§° 6ï¸âƒ£ Resource Names and Uniqueness

Within one namespace:

* All object names (Pods, Services, ConfigMaps, etc.) must be **unique**.

Between namespaces:

* The same object name can exist in multiple namespaces.

âœ… Example:

```
Pod â€œnginxâ€ in namespace â€œdevâ€
Pod â€œnginxâ€ in namespace â€œprodâ€
```

â†’ Both are valid because theyâ€™re in different namespaces.

---

## ğŸ§® 7ï¸âƒ£ Resource Quotas in Namespaces

You can restrict resource usage per namespace using **ResourceQuota**.

Example:

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: compute-quota
  namespace: dev
spec:
  hard:
    pods: "10"
    requests.cpu: "2"
    requests.memory: 4Gi
    limits.cpu: "4"
    limits.memory: 8Gi
```

This ensures the `dev` namespace canâ€™t use more than its allocated share of resources.

---

## ğŸ§± 8ï¸âƒ£ LimitRange (Per Pod/Container Resource Limit)

Inside a namespace, you can also define **LimitRange** â€”
to automatically enforce default CPU/memory limits for each pod or container.

Example:

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: cpu-limit-range
  namespace: dev
spec:
  limits:
  - default:
      cpu: 500m
      memory: 256Mi
    defaultRequest:
      cpu: 200m
      memory: 128Mi
    type: Container
```

This prevents one container from consuming all node resources.

---

## ğŸ” 9ï¸âƒ£ Namespaces and RBAC (Access Control)

Namespaces are key to implementing **Role-Based Access Control (RBAC)**.

You can:

* Grant specific users or groups access to specific namespaces.
* Isolate permissions between teams.

Example:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: dev
  name: dev-role
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "watch", "list"]
```

Then bind it with a RoleBinding to a specific user.

---

## ğŸ’¬ 10ï¸âƒ£ Viewing Resources Across All Namespaces

To see all resources in every namespace:

```bash
kubectl get pods --all-namespaces
```

To view other objects (services, deployments, etc.):

```bash
kubectl get all --all-namespaces
```

---

## ğŸ§  Summary of Namespaces

| Feature                | Description                                        |
| ---------------------- | -------------------------------------------------- |
| **Purpose**            | Logical separation of resources                    |
| **Scope**              | Cluster-wide                                       |
| **Benefits**           | Isolation, access control, quotas                  |
| **Default Namespaces** | default, kube-system, kube-public, kube-node-lease |
| **Common Uses**        | Dev/Prod isolation, multi-team environments        |

---

## âš™ï¸ 11ï¸âƒ£ What Are Contexts?

Namespaces define *where* resources live.
**Contexts** define *which cluster, user, and namespace* youâ€™re currently working in.

A **context** is part of your **kubeconfig file** (`~/.kube/config`).

---

### ğŸ“„ kubeconfig Structure Example

```yaml
apiVersion: v1
clusters:
- cluster:
    server: https://192.168.49.2:8443
  name: dev-cluster
contexts:
- context:
    cluster: dev-cluster
    user: dev-user
    namespace: dev
  name: dev-context
current-context: dev-context
kind: Config
preferences: {}
users:
- name: dev-user
  user:
    client-certificate: /path/dev.crt
    client-key: /path/dev.key
```

---

### ğŸ”¹ Key Elements

| Field               | Meaning                                |
| ------------------- | -------------------------------------- |
| **Cluster**         | Which Kubernetes cluster to connect to |
| **User**            | Which credentials to use               |
| **Namespace**       | Default namespace for this context     |
| **Context**         | Combines cluster + user + namespace    |
| **current-context** | The context currently active           |

---

## ğŸ§­ 12ï¸âƒ£ Managing Contexts

### List all contexts:

```bash
kubectl config get-contexts
```

### View the current context:

```bash
kubectl config current-context
```

### Switch to another context:

```bash
kubectl config use-context dev-context
```

### Set a default namespace for a context:

```bash
kubectl config set-context --current --namespace=dev
```

Now all commands (like `kubectl get pods`) default to the `dev` namespace.

---

## ğŸ’¡ 13ï¸âƒ£ Multi-Cluster & Multi-User Environments

Contexts are especially useful when:

* You manage **multiple clusters** (e.g., dev, staging, prod).
* You have **different credentials** for each cluster.
* You want to quickly switch between clusters or namespaces without retyping `--namespace` or `--server`.

---

## ğŸ§  14ï¸âƒ£ Namespaces vs. Contexts â€” Difference

| Feature        | **Namespace**                      | **Context**                                                        |
| -------------- | ---------------------------------- | ------------------------------------------------------------------ |
| **Definition** | Logical partition inside a cluster | Configuration in kubeconfig combining cluster, user, and namespace |
| **Scope**      | Cluster-level                      | Userâ€™s kubeconfig-level                                            |
| **Purpose**    | Isolate workloads and resources    | Easily switch between clusters and namespaces                      |
| **Example**    | `kubectl get pods -n dev`          | `kubectl config use-context dev-context`                           |

---

## ğŸ§© Visualization â€” Cluster with Multiple Namespaces and Contexts

```
Kubernetes Cluster
â”‚
â”œâ”€â”€ Namespace: dev
â”‚   â”œâ”€â”€ Pod: frontend
â”‚   â”œâ”€â”€ Pod: backend
â”‚   â””â”€â”€ Service: dev-service
â”‚
â”œâ”€â”€ Namespace: prod
â”‚   â”œâ”€â”€ Pod: frontend
â”‚   â”œâ”€â”€ Pod: backend
â”‚   â””â”€â”€ Service: prod-service
â”‚
â””â”€â”€ Namespace: monitoring
    â”œâ”€â”€ Pod: prometheus
    â””â”€â”€ Pod: grafana
```

Contexts in your kubeconfig might look like:

* `dev-context` â†’ Cluster + dev namespace
* `prod-context` â†’ Cluster + prod namespace
* `monitoring-context` â†’ Cluster + monitoring namespace

---

## ğŸ§¾ 15ï¸âƒ£ Real-World Example

**Scenario:**
Youâ€™re managing two environments â€” Dev and Prod â€” in the same cluster.

### Step 1: Create namespaces

```bash
kubectl create namespace dev
kubectl create namespace prod
```

### Step 2: Create contexts

```bash
kubectl config set-context dev-context --cluster=kubernetes --user=admin --namespace=dev
kubectl config set-context prod-context --cluster=kubernetes --user=admin --namespace=prod
```

### Step 3: Switch between environments

```bash
kubectl config use-context dev-context
# Work on dev

kubectl config use-context prod-context
# Work on prod
```

Easy switching = fewer mistakes ğŸš€

---

## âœ… Summary

| Concept                | Description                                           |
| ---------------------- | ----------------------------------------------------- |
| **Namespace**          | Logical partition in a cluster for resource isolation |
| **Purpose**            | Separate environments, manage resources, apply quotas |
| **Default Namespaces** | default, kube-system, kube-public, kube-node-lease    |
| **Context**            | Configuration combining cluster + user + namespace    |
| **Purpose**            | Simplifies working with multiple clusters/namespaces  |
| **Key Command**        | `kubectl config use-context`                          |

---

Namespaces organize **what** you manage inside the cluster.
Contexts organize **where and as whom** you manage it from outside.

---