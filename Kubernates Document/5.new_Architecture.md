**Topic 1: Kubernetes Architecture** — the *heart and brain* of the entire Kubernetes system.
Understanding this deeply will make every other concept (Pods, Deployments, etc.) crystal clear.

---

# 🏗️ **Kubernetes Architecture — Complete In-Depth Explanation**

---

## 🌍 What Is Kubernetes?

Kubernetes (often abbreviated as **K8s**) is an **open-source container orchestration platform** developed by Google and now maintained by the CNCF (Cloud Native Computing Foundation).

It automates:

* Deployment
* Scaling
* Load balancing
* Self-healing
  of **containerized applications**.

In simple terms — you tell Kubernetes **what** you want (desired state), and it takes care of **how** to make it happen.

---

## ⚙️ High-Level Overview

A **Kubernetes Cluster** consists of two main parts:

1. **Control Plane (Master)** — the *brain* that makes decisions.
2. **Worker Nodes** — the *muscles* that execute those decisions and actually run your applications.

```
+-------------------------------------------------------------+
|                     Kubernetes Cluster                      |
|-------------------------------------------------------------|
|                       CONTROL PLANE                         |
|   - kube-apiserver                                          |
|   - etcd                                                    |
|   - kube-controller-manager                                 |
|   - kube-scheduler                                          |
|-------------------------------------------------------------|
|                       WORKER NODES                          |
|   - kubelet                                                 |
|   - kube-proxy                                              |
|   - container runtime                                       |
|   - Pods (your apps)                                        |
+-------------------------------------------------------------+
```

Let’s now break down each component — in theory, and in behavior.

---

## 🧠 **1. Control Plane — The Brain of Kubernetes**

The Control Plane manages and maintains the overall cluster state.
It decides what runs where, when, and how.

It has four main components:

* **kube-apiserver**
* **etcd**
* **kube-scheduler**
* **kube-controller-manager**

Let’s explore each one in detail 👇

---

### ⚡ **a) kube-apiserver (API Server)**

**Definition:**
The `kube-apiserver` is the **front door** of the Kubernetes control plane.
All interactions — whether from users, scripts, controllers, or other components — go through it.

You can think of it as:

* The **traffic controller** for the cluster.
* The **RESTful API gateway** that manages all communication.

---

**Responsibilities:**

* Accepts requests from `kubectl`, dashboards, and other clients.
* Validates and authenticates incoming requests.
* Persists data into `etcd`.
* Serves data to internal and external consumers.

---

**Example Flow:**

1. You apply a YAML file:

   ```bash
   kubectl apply -f pod.yaml
   ```
2. `kubectl` sends this to the **API Server**.
3. The API Server validates it.
4. It stores the “desired state” (Pod specification) in `etcd`.
5. Other components (scheduler, controllers) react to this change.

---

**Protocols:**

* Uses **HTTP/HTTPS (REST API)**.
* Exposes the Kubernetes API on port `6443`.
* Communicates securely with other components using **TLS**.

---

**Analogy:**

* Think of it as a **reception desk** in a large organization — every request passes through it before being processed.

---

### 🗄️ **b) etcd**

**Definition:**
`etcd` is a **distributed, consistent key-value store** that stores *all cluster data*.

It’s the **source of truth** for Kubernetes — every configuration, object, and current cluster state lives here.

---

**Data Stored in etcd:**

* Cluster configuration and metadata
* Pod and Node states
* Secrets, ConfigMaps, Roles, and Bindings
* Endpoints and network data

Example structure (key-value):

```
/registry/pods/default/nginx
/registry/nodes/node01
/registry/secrets/default/db-secret
```

---

**Features:**

* Highly available and consistent (based on Raft consensus algorithm).
* Provides backup and restore capabilities.
* Ensures no “split-brain” in cluster state.

---

**Importance:**
If you lose `etcd`, you lose your cluster’s memory.
So it’s crucial to take regular **etcd snapshots**.

---

**Command Example (on control plane):**

```bash
etcdctl get /registry/pods/default/nginx --prefix --keys-only
```

---

**Analogy:**

* Think of `etcd` as the **cluster’s brain memory**.
  It remembers what should exist and what state things are in.

---

### ⚙️ **c) kube-controller-manager**

**Definition:**
The `kube-controller-manager` runs a set of background processes called **controllers**.

Controllers continuously watch the cluster’s state and try to move the *current state* closer to the *desired state*.

---

**Examples of Controllers:**

| Controller                     | Responsibility                                        |
| ------------------------------ | ----------------------------------------------------- |
| **Node Controller**            | Detects and reacts to node failures.                  |
| **Replication Controller**     | Ensures correct number of pod replicas.               |
| **Deployment Controller**      | Manages rolling updates & rollbacks.                  |
| **Endpoint Controller**        | Populates endpoint objects when services/pods change. |
| **Service Account Controller** | Creates default accounts for new namespaces.          |

---

**How It Works:**

* Each controller watches the API server for changes.
* When it sees a discrepancy, it takes corrective action.

📘 Example:
If a Deployment specifies **3 replicas** but only **2 pods** are running,
the controller-manager creates the missing Pod automatically.

---

**Analogy:**

* Think of it as the **manager** of your team — constantly ensuring that everyone is doing what they’re supposed to.

---

### 📅 **d) kube-scheduler**

**Definition:**
The `kube-scheduler` is responsible for **deciding where a new Pod should run**.

When a Pod is created, it’s initially in the **Pending** state.
The scheduler then picks the most suitable **Node** for it.

---

**How It Works:**

1. The scheduler looks for Pods with **no assigned node**.
2. It evaluates all available nodes.
3. Based on multiple criteria, it chooses the best one.
4. It assigns the Pod to that Node.

---

**Scheduling Criteria:**

* Resource requests (CPU, memory)
* Node taints and tolerations
* Node affinity/anti-affinity
* Pod affinity/anti-affinity
* Data locality
* Node selectors

---

**Example:**
If a Pod requests 1 CPU and 512Mi memory,
and Node A has available capacity, but Node B doesn’t —
the Pod will be scheduled on Node A.

---

**Analogy:**

* Think of the scheduler as a **placement planner** —
  deciding which employee (Pod) should sit in which office (Node).

---

## 🧱 **2. Worker Nodes — The Execution Layer**

Worker nodes actually **run your applications**.
Each node has the components required to communicate with the control plane and manage containers.

---

### ⚙️ **a) kubelet**

**Definition:**
The `kubelet` is an **agent** running on every node.
It ensures that the containers described in PodSpecs are running and healthy.

---

**Responsibilities:**

* Registers the node with the control plane.
* Monitors Pod status and reports to the API server.
* Starts, stops, and restarts containers using the container runtime.

If a Pod crashes, the `kubelet` ensures it is recreated (if controlled by a higher-level controller like a Deployment).

---

**Workflow Example:**

1. Scheduler assigns Pod → Node.
2. `kubelet` receives Pod definition.
3. It tells the **container runtime** (e.g., containerd) to pull image & start container.
4. Reports Pod status back to API server.

---

**Command Example:**

```bash
kubectl describe node <node-name>
```

---

### 🌐 **b) kube-proxy**

**Definition:**
`kube-proxy` maintains network rules on nodes.
It enables network communication to your Pods, inside and outside the cluster.

---

**Functions:**

* Implements **Service** networking.
* Handles load balancing across Pods.
* Manages **iptables** or **IPVS** rules for routing.

---

**Example:**
When you create a Service of type `ClusterIP`, `kube-proxy` ensures that:

* Requests sent to the Service IP are distributed among healthy Pods.

---

### 🐳 **c) Container Runtime**

**Definition:**
This is the **software that runs containers**.

Common runtimes:

* `containerd`
* `CRI-O`
* (Previously Docker, now deprecated as CRI runtime)

---

**Responsibilities:**

* Pulls container images.
* Starts/stops containers.
* Reports container status to kubelet.

---

## 🧩 How the Components Interact

Let’s connect the dots — here’s what happens when you deploy something:

1. You run:

   ```bash
   kubectl apply -f nginx.yaml
   ```
2. `kubectl` → talks to **API Server**.
3. API Server validates & stores configuration in **etcd**.
4. **Controller Manager** sees desired state → creates Pod.
5. **Scheduler** finds best Node.
6. **kubelet** on that Node runs the Pod.
7. **kube-proxy** handles networking for it.

This continuous cycle keeps the cluster running and self-healing.

---

## 🧠 Kubernetes Architecture Summary

| Component                   | Location      | Function                         |
| --------------------------- | ------------- | -------------------------------- |
| **kube-apiserver**          | Control Plane | Entry point for API calls        |
| **etcd**                    | Control Plane | Key–value store for cluster data |
| **kube-controller-manager** | Control Plane | Maintains desired cluster state  |
| **kube-scheduler**          | Control Plane | Assigns Pods to Nodes            |
| **kubelet**                 | Worker Node   | Runs and manages containers      |
| **kube-proxy**              | Worker Node   | Manages networking rules         |
| **Container Runtime**       | Worker Node   | Executes containerized workloads |

---

## 🔐 Bonus: Security & Communication

All communication between components uses:

* **TLS encryption**
* **Certificates for authentication**
* **Role-Based Access Control (RBAC)** for authorization

This ensures cluster security and isolation.

---

## 🧭 Real-Life Analogy

| Concept                | Analogy             | Description                      |
| ---------------------- | ------------------- | -------------------------------- |
| **API Server**         | Reception desk      | Handles all incoming requests    |
| **etcd**               | Filing cabinet      | Stores all records               |
| **Controller Manager** | Manager             | Ensures everything is as planned |
| **Scheduler**          | HR                  | Assigns work to employees        |
| **Node**               | Department          | Where actual work happens        |
| **Pod**                | Employee team       | Executes tasks                   |
| **Container**          | Individual employee | Performs actual work             |

---

That’s the **entire Kubernetes architecture**, broken down to the deepest conceptual level 💡

---

