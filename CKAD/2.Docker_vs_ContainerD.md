ğŸ³ Docker vs Containerd vs CRI â€” Understanding the Evolution of Container Runtimes

As you continue learning Kubernetes, youâ€™ll often come across terms like **Docker**, **containerd**, and sometimes a few command-line tools such as **ctr**, **nerdctl**, or **crictl**.
If youâ€™ve read older blogs or documentation, youâ€™ll mostly see **Docker** mentioned alongside Kubernetes. But in newer materials, youâ€™ll notice **containerd** being used instead, and that can cause some confusion. So, whatâ€™s the difference between Docker and containerd, and which tools should you actually be using? Letâ€™s break it down.

---

## ğŸ•°ï¸ A Quick Look Back â€” The Beginning of Containers

In the early days of containers, **Docker** was the primary tool for containerization. Although there were other tools like **rkt (Rocket)**, Dockerâ€™s simplicity and excellent developer experience made it the dominant container platform.

When **Kubernetes** was first created, it was designed specifically to orchestrate **Docker containers**. In other words, Kubernetes and Docker were tightly coupled, and Kubernetes initially worked **only** with Docker.

As Kubernetes became the standard for container orchestration, new container runtimes such as **rkt** and **containerd** emerged. Developers wanted Kubernetes to support these runtimes as well, not just Docker. To make this possible, Kubernetes introduced the **Container Runtime Interface (CRI)** â€” a standard interface that allowed any container runtime to integrate with Kubernetes, as long as it followed **Open Container Initiative (OCI)** specifications.

---

## ğŸ§± The Role of OCI and CRI

The **Open Container Initiative (OCI)** defines two main specifications:

1. **Image Specification** â€“ defines how container images should be built and formatted.
2. **Runtime Specification** â€“ defines how container runtimes should be developed and how they should run containers.

Any container runtime following these standards can work with Kubernetes through the **CRI**.

However, Docker was created **before CRI** existed, meaning it didnâ€™t natively support the CRI standard. To maintain compatibility, Kubernetes introduced a component called **dockershim**, a temporary workaround that allowed Kubernetes to communicate with Docker outside of the CRI.

---

## âš™ï¸ Understanding Dockerâ€™s Architecture

Docker isnâ€™t just a container runtime â€” itâ€™s a **complete platform**.
It includes:

* The **Docker CLI** and **API** for managing containers
* Image build tools
* Networking and volume management
* Security features
* And the **container runtime**, which consists of two core parts:

  * **containerd** â€” the daemon that manages container lifecycle
  * **runc** â€” the low-level runtime that actually runs containers

So, **containerd** was originally part of Docker but later became a **separate, standalone project**.

Since **containerd** is fully CRI-compliant, it can work directly with Kubernetes without Docker. This made Dockerâ€™s dockershim unnecessary. As a result, starting from **Kubernetes v1.24**, support for Docker as a runtime was officially **removed**.

---

## ğŸ§© What Changed After Docker Support Was Removed

Even though Docker itself was removed as a runtime, all **Docker-built images still work perfectly fine**.
Thatâ€™s because Docker images already comply with the OCI image specification.

Now, Kubernetes typically runs containers using **containerd** or other CRI-compatible runtimes like **CRI-O**.
So, Docker is no longer required for Kubernetes, though itâ€™s still widely used for **building** and **testing** container images locally.

---

## ğŸ§° Working with containerd

If Docker isnâ€™t installed, how do you run containers with containerd?
When you install **containerd**, it comes with its own CLI tool called **`ctr`**.

The `ctr` command is mainly intended for **debugging** and **low-level container operations**. Itâ€™s not very user-friendly, supports limited functionality, and isnâ€™t recommended for production use.

Example commands:

* Pull an image:

  ```bash
  ctr images pull docker.io/library/redis:latest
  ```
* Run a container:

  ```bash
  ctr run docker.io/library/redis:latest redis-container
  ```

However, since `ctr` is minimal and meant for internal debugging, developers needed a better alternative.

---

## ğŸ§  Introducing nerdctl (Nerd Control)

**`nerdctl`** is a Docker-like CLI for **containerd**. Itâ€™s easy to use and supports almost all Docker commands, making migration from Docker to containerd smooth and intuitive.

You can simply replace `docker` with `nerdctl` in most commands. For example:

```bash
nerdctl run -d -p 8080:80 nginx
```

`nerdctl` also provides advanced features not yet available in Docker, such as:

* **Encrypted container images**
* **Lazy image pulling**
* **P2P (peer-to-peer) image distribution**
* **Image signing and verification**
* **Kubernetes namespaces support**

Because of this, `nerdctl` is the recommended CLI for working with containerd in real-world environments.

---

## ğŸ” CRICTL â€” The Kubernetes Debugging Tool

Another important tool is **`crictl`** (pronounced *cry-control*), developed by the Kubernetes community.
This tool allows you to interact directly with any **CRI-compatible container runtime**, such as containerd or CRI-O.

Unlike `ctr` and `nerdctl` (which are part of the containerd ecosystem), `crictl` is from the **Kubernetes side** and is primarily used for **debugging containers and pods** on worker nodes.

Example commands:

```bash
crictl ps           # List running containers
crictl images       # List available images
crictl logs <id>    # View container logs
crictl exec -it <id> sh   # Run a command inside a container
crictl pods         # List running pods
```

However, `crictl` isnâ€™t designed to create or manage containers manually. Itâ€™s mainly used for **inspection and troubleshooting**.
If you try to create containers manually using `crictl`, the **kubelet** will eventually delete them, since theyâ€™re not part of Kubernetesâ€™ managed workloads.

---

## ğŸ§© Summary of Tools

| Tool        | Developed By         | Works With                                            | Purpose                        | User-Friendliness |
| ----------- | -------------------- | ----------------------------------------------------- | ------------------------------ | ----------------- |
| **ctr**     | containerd community | containerd                                            | Debugging                      | Low               |
| **nerdctl** | containerd community | containerd                                            | General container management   | High              |
| **crictl**  | Kubernetes community | All CRI-compatible runtimes (e.g., containerd, CRI-O) | Debugging Kubernetes workloads | Medium            |

---

## ğŸ§¾ Key Takeaways

* **Docker** used to be the only container runtime supported by Kubernetes.
* **Containerd** emerged as a CRI-compliant alternative and is now the default runtime for most Kubernetes setups.
* **Docker support was removed in Kubernetes v1.24**, but Docker-built images still work fine.
* **`ctr`** â†’ Low-level debugging tool for containerd.
* **`nerdctl`** â†’ Docker-like CLI for containerd; recommended for daily use.
* **`crictl`** â†’ Kubernetes community tool for debugging containers and pods.

Today, most Kubernetes clusters use **containerd** as the default runtime, along with **nerdctl** for general container management and **crictl** for cluster-level debugging.