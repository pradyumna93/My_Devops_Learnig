## **Kubernetes Service: ClusterIP**

### **1. Overview**

In a full-stack web application, different pods host different parts of the system:

* **Frontend pods** → Host the web server
* **Backend pods** → Handle application logic
* **Redis pods** → Act as key-value stores
* **Database pods (e.g., MySQL)** → Handle data persistence

These components need to **communicate internally** — for example:

* The frontend connects to the backend.
* The backend connects to Redis and the database.

---

### **2. The Problem: Dynamic Pod IPs**

Each pod has its **own IP address**, but:

* Pod IPs are **temporary** — they can change when pods are recreated.
* Therefore, you **cannot rely on pod IPs** for internal communication.

**Example:**
If a frontend pod (`10.244.0.3`) wants to talk to the backend,

* Which backend pod (out of multiple) should it contact?
* Who decides that?

---

### **3. Solution: Kubernetes Service**

A **Service** in Kubernetes:

* Groups multiple pods under a **single logical name and IP**.
* Provides a **stable endpoint** for communication.
* Distributes traffic among pods (load balancing).

**Example:**

* A **backend service** groups all backend pods together.
* A **Redis service** groups all Redis pods together.
* Frontend pods can then access the backend using the service name (not pod IP).

---

### **4. Why Use Services?**

* Simplifies **communication** between application tiers.
* Allows **independent scaling** of each layer.
* Makes **pods replaceable** without breaking connectivity.
* Enables **microservices architecture** inside the cluster.

---

### **5. ClusterIP Type**

* The **default type of service** is **ClusterIP**.
* It is **accessible only within the cluster** (not externally).

Each service gets:

* A **unique Cluster IP**.
* A **DNS name** (auto-created in Kubernetes DNS).

Pods inside the cluster can communicate using:

```
<service-name>
```

or

```
<service-name>.<namespace>.svc.cluster.local
```

---

### **6. Example: Creating a ClusterIP Service**

#### **Service Definition YAML**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: backend
spec:
  type: ClusterIP        # Default type (can be omitted)
  selector:
    app: backend         # Label of backend pods
  ports:
    - port: 80           # Service port (exposed to others)
      targetPort: 80     # Port on backend pods
```

#### **Pod Definition Example (for reference)**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: backend-pod
  labels:
    app: backend
spec:
  containers:
    - name: backend
      image: my-backend-app
      ports:
        - containerPort: 80
```

---

### **7. Commands**

| Task                            | Command                                  |
| ------------------------------- | ---------------------------------------- |
| Create the service              | `kubectl create -f backend-service.yaml` |
| List all services               | `kubectl get svc`                        |
| Describe service details        | `kubectl describe svc backend`           |
| Access service from another pod | Use service name: `backend`              |

---

### **8. Summary**

* Pods have dynamic IPs → Services provide stability.
* **ClusterIP** service = internal-only communication.
* Other service types (like NodePort, LoadBalancer) expose services externally (discussed later).
* Services ensure microservices in Kubernetes can communicate reliably.

---
