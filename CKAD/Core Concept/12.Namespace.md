Sure â€” hereâ€™s your lecture rewritten in **clear, structured, and easy-to-read notes format**, with # ğŸ§­ Kubernetes Namespaces â€” Lecture Notes

## ğŸ”¹ Understanding Namespaces with an Analogy

Letâ€™s begin with an analogy:
Imagine there are two boys named **Mark**.
To differentiate them, we refer to them by their **last names** â€” Mark Smith and Mark Williams.

They belong to different houses:

* **The Smiths** and **The Williams**.
* Inside each house, members call each other by their **first names** only.

  * For example, the father calls his son just â€œMark.â€
* However, if someone outside the house wants to refer to Mark, they use the **full name**, such as â€œMark Smith.â€

Each house has:

* Its own **rules** (who does what)
* Its own **resources** (food, space, etc.)

---

## ğŸ”¹ The Kubernetes Analogy

In Kubernetes:

* Each **house** represents a **namespace**.
* A **namespace** groups and isolates resources like **pods, deployments, and services**.

So far, everything weâ€™ve created (pods, deployments, etc.) has been within a **namespace** â€” specifically, the **default namespace**, which Kubernetes creates automatically when a cluster is set up.

---

## ğŸ”¹ Built-in Namespaces in Kubernetes

Kubernetes automatically creates a few namespaces for its own use:

1. **default** â€“
   The default workspace where user-created objects go unless specified otherwise.

2. **kube-system** â€“
   Contains system components like the **DNS service**, **networking pods**, and other internal resources.

3. **kube-public** â€“
   Contains resources meant to be accessible by **all users**.

---

## ğŸ”¹ Why Use Namespaces?

Namespaces help when:

* You want to **separate environments** (e.g., dev, test, prod) within the same cluster.
* You need **access control** or **resource quotas** per environment.

Example:

* You can create two namespaces: `dev` and `prod`.
* This separation ensures you donâ€™t accidentally modify production resources while working in development.

Each namespace can have:

* Its own **policies** (who can do what)
* Its own **resource quotas** (how much CPU, memory, etc. can be used)

---

## ğŸ”¹ Communication Between Resources

* Within a namespace, resources can refer to each other **by name only**.
  Example:
  The `webapp` pod can access the `db-service` using simply `db-service`.

* Across namespaces, you must use the **fully qualified domain name (FQDN)** format:

  ```
  <service-name>.<namespace>.svc.cluster.local
  ```

  Example:
  A pod in the `default` namespace accessing `db-service` in the `dev` namespace will use:

  ```
  db-service.dev.svc.cluster.local
  ```

Here:

* `svc` â†’ indicates the **service subdomain**
* `cluster.local` â†’ the **default domain name** of the Kubernetes cluster

---

## ğŸ”¹ Working with Namespaces â€” Commands

### 1. List Pods in a Namespace

By default:

```bash
kubectl get pods
```

shows pods in the **default namespace**.

To list pods in another namespace:

```bash
kubectl get pods -n kube-system
```

To list pods in **all namespaces**:

```bash
kubectl get pods --all-namespaces
```

---

## ğŸ”¹ Creating Resources in a Specific Namespace

When creating a pod using a YAML file, itâ€™s created in the **default namespace** unless specified.

### Option 1: Specify Namespace in Command

```bash
kubectl create -f pod.yaml -n dev
```

### Option 2: Specify Namespace Inside YAML

In your pod definition file, add this under `metadata`:

```yaml
metadata:
  name: my-pod
  namespace: dev
```

âœ… This ensures the pod is always created in the correct namespace.

---

## ğŸ”¹ Creating a New Namespace

### Using YAML:

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: dev
```

Command:

```bash
kubectl create -f namespace.yaml
```

### Using Command Line:

```bash
kubectl create namespace dev
```

---

## ğŸ”¹ Switching Between Namespaces

By default, youâ€™re in the **default** namespace.
To switch your **current context** to a different namespace:

```bash
kubectl config set-context --current --namespace=dev
```

Now, when you run:

```bash
kubectl get pods
```

it will show pods from the `dev` namespace.

To switch to another (e.g., prod):

```bash
kubectl config set-context --current --namespace=prod
```

---

## ğŸ”¹ Contexts and Namespaces

A **context** in Kubernetes stores:

* Cluster information
* User credentials
* Namespace settings

Changing the namespace in a context means you donâ€™t need to use the `-n` flag repeatedly.

(Weâ€™ll cover **contexts** in a dedicated lecture.)

---

## ğŸ”¹ Limiting Resources in a Namespace â€” Resource Quotas

To restrict or allocate specific resources per namespace, create a **ResourceQuota** object.

### Example YAML:

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: dev-quota
  namespace: dev
spec:
  hard:
    pods: "10"
    requests.cpu: "10"
    requests.memory: "10Gi"
```

This ensures:

* Maximum 10 pods
* 10 CPU units
* 10 GB memory usage in the `dev` namespace

---

## ğŸ§© Summary

| Concept              | Description                                               |
| -------------------- | --------------------------------------------------------- |
| **Namespace**        | Logical isolation of Kubernetes resources                 |
| **default**          | Default user namespace                                    |
| **kube-system**      | System pods and services                                  |
| **kube-public**      | Shared/public resources                                   |
| **Communication**    | Same namespace â†’ by name; cross-namespace â†’ use FQDN      |
| **ResourceQuota**    | Limits resource usage per namespace                       |
| **Switch Namespace** | `kubectl config set-context --current --namespace=<name>` |

---
