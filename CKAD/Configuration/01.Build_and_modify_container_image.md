## ğŸ³ **Lecture: Creating Your Own Docker Image**

### ğŸ”¹ Introduction

Hello and welcome to this lecture on **Docker Images**.
In this session, weâ€™ll learn **how to create your own Docker image** from scratch.

---

### ğŸ’¡ Why Create Your Own Image?

You might need to create a custom Docker image for one of the following reasons:

1. The component or service you need is **not available on Docker Hub**.
2. Your team has decided to **Dockerize the application** for easier deployment, portability, and consistency across environments.

In this example, weâ€™ll containerize a simple **Python Flask web application**.

---

### ğŸ§  Step 1: Understand What Youâ€™re Containerizing

Before writing a Dockerfile, itâ€™s important to understand your application and how you would set it up manually.

If you were deploying the Flask app manually, you would:

1. Start with an **operating system** (like Ubuntu).
2. **Update package repositories** using `apt-get update`.
3. **Install system dependencies** using `apt-get install`.
4. **Install Python dependencies** using `pip install`.
5. **Copy your source code** to a directory (for example, `/opt/app`).
6. **Start the web server** using the `flask run` command.

---

### ğŸ§¾ Step 2: Create a Dockerfile

Once you understand the setup steps, the next step is to create a **Dockerfile** â€” a text file that contains all the instructions for building your image.

#### Example: Python Flask Application

```dockerfile
FROM ubuntu
RUN apt-get update && apt-get install -y python3 python3-pip
COPY . /opt/app
WORKDIR /opt/app
RUN pip install -r requirements.txt
ENTRYPOINT ["python3", "app.py"]
```

---

### ğŸ›  Step 3: Build the Image

Use the `docker build` command to create your image:

```bash
docker build -t mycustomapp .
```

This command builds the Docker image using the **Dockerfile** in the current directory and tags it as **mycustomapp**.

---

### ğŸŒ Step 4: Push the Image to Docker Hub

To share your image publicly:

```bash
docker tag mycustomapp <your-dockerhub-username>/mycustomapp
docker push <your-dockerhub-username>/mycustomapp
```

Example:

```bash
docker push emumshaw/mycustomapp
```

---

### ğŸ§© Understanding the Dockerfile

A **Dockerfile** follows a simple instructionâ€“argument structure.
For example:

* `FROM` â€“ Defines the **base image** (e.g., Ubuntu).
* `RUN` â€“ Executes commands to install software or update packages.
* `COPY` â€“ Copies files from your local machine into the image.
* `ENTRYPOINT` â€“ Defines the command that runs when the container starts.

> Every Dockerfile must start with a `FROM` instruction.

---

### ğŸ§± Docker Image Layers

Docker images are built in **layers**.
Each instruction in the Dockerfile creates a new layer that stores only the **changes** from the previous layer.

Example of layers:

1. **Base OS layer** â€“ Ubuntu (~120 MB)
2. **APT packages layer** â€“ (~300 MB)
3. **Python dependencies layer**
4. **Source code layer**
5. **Entry point layer**

You can view these layers using:

```bash
docker history mycustomapp
```

---

### âš™ï¸ Layer Caching & Rebuilds

Docker **caches layers** to make builds faster.
If a step fails or you make small changes, Docker reuses previously built layers.

For example, if Step 3 fails during `docker build`, fixing the issue and rerunning the build will reuse cached layers from Steps 1 and 2 â€” saving time.
This also applies when you modify your application code: only the updated layers are rebuilt.

---

### ğŸŒ Applications You Can Containerize

You can containerize almost any application, from simple utilities to complex frameworks.
Here are some examples:

---

#### ğŸ **Python Flask**

```dockerfile
FROM python:3.11
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt
CMD ["python", "app.py"]
```

---

#### ğŸŸ¢ **Node.js**

```dockerfile
FROM node:18
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
CMD ["npm", "start"]
```

---

#### âš›ï¸ **React**

```dockerfile
FROM node:18 as build
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
```

---

#### ğŸ§° **.NET Core**

```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /source
COPY . .
RUN dotnet publish -c release -o /app

FROM mcr.microsoft.com/dotnet/aspnet:8.0
WORKDIR /app
COPY --from=build /app .
ENTRYPOINT ["dotnet", "MyApp.dll"]
```

---

#### ğŸ—„ **MySQL Database**

You can run official MySQL containers or build a custom one with preloaded data.

```dockerfile
FROM mysql:8.0
ENV MYSQL_ROOT_PASSWORD=root
ENV MYSQL_DATABASE=mydb
COPY ./init.sql /docker-entrypoint-initdb.d/
```

---

#### ğŸ—ƒ **PostgreSQL Database**

Similarly, you can containerize PostgreSQL.

```dockerfile
FROM postgres:16
ENV POSTGRES_USER=admin
ENV POSTGRES_PASSWORD=admin
ENV POSTGRES_DB=mydb
COPY ./init.sql /docker-entrypoint-initdb.d/
```

---

#### ğŸ§© **Other Examples**

* Databases like **MongoDB**, **Redis**, **MariaDB**
* Utilities like **curl**, **nginx**, **httpd**
* Desktop apps like **Spotify**, **Skype**, etc.

---

### ğŸš€ Future of Application Deployment

In the modern DevOps world, almost **every application will be containerized**.
Instead of installing software manually, users and developers will simply **run containers using Docker**.
And when they no longer need them, they can remove them effortlessly â€” no cleanup required.

---

### âœ… **Key Takeaways**

* Docker images are built using **Dockerfiles** with defined instructions.
* Each **instruction creates a new image layer**.
* Docker uses **layer caching** to optimize rebuilds.
* You can containerize **any application** â€” from Flask, Node.js, React, .NET, MySQL, PostgreSQL, and beyond.
* Containerization ensures **portability, scalability, and ease of deployment**.

---
