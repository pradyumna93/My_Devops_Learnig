## ğŸ§  **Kubernetes Secrets â€” Complete Hands-On Guide**

### ğŸ¯ **Objective**

Learn how to:

* Create, encode, and manage Kubernetes Secrets
* Inject secrets into Pods as environment variables or mounted files
* Understand the difference between ConfigMaps and Secrets

---

## ğŸ” **1. Why Secrets?**

Applications often require sensitive information such as:

* Database passwords
* API keys
* Certificates

Hardcoding these values directly into source code or ConfigMaps is insecure.

âœ… **Solution:**
Use **Kubernetes Secrets** â€” a native way to store sensitive data **encoded in Base64** format.

---

## âš™ï¸ **2. Ways to Create Secrets**

You can create secrets in **two ways**:

1. **Imperative (CLI)**
2. **Declarative (YAML)**

---

### ğŸ§© **A. Imperative Method (via CLI)**

#### **Example 1: Create Secret with Literal Values**

```bash
kubectl create secret generic app-secret --from-literal=DB_HOST=mysql
```

âœ… Creates a secret named `app-secret` with one key-value pair:

```
DB_HOST = mysql
```

#### **Add Multiple Values**

```bash
kubectl create secret generic app-secret \
  --from-literal=DB_HOST=mysql \
  --from-literal=DB_USER=root \
  --from-literal=DB_PASS=Passw0rd123
```

---

#### **Example 2: Create Secret from a File**

If you have a file named `db-pass.txt` containing:

```
Passw0rd123
```

Run:

```bash
kubectl create secret generic app-secret --from-file=db-pass.txt
```

âœ… The key becomes the filename (`db-pass.txt`), and the value is the fileâ€™s content.

---

### ğŸ§¾ **B. Declarative Method (via YAML Definition)**

Create a file called `secret.yaml`:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: app-secret
type: Opaque
data:
  DB_HOST: bXlzcWw=         # mysql
  DB_USER: cm9vdA==         # root
  DB_PASS: UGFzc3cwcmQxMjM= # Passw0rd123
```

ğŸ“˜ Note:
The values must be **Base64 encoded**.

---

## ğŸ”¢ **3. Encode & Decode Secrets**

### **Encoding (Base64)**

```bash
echo -n 'mysql' | base64
# Output: bXlzcWw=
```

### **Decoding**

```bash
echo 'bXlzcWw=' | base64 --decode
# Output: mysql
```

---

## ğŸ§¾ **4. View Secrets**

### **List all secrets**

```bash
kubectl get secrets
```

### **Describe a specific secret**

```bash
kubectl describe secret app-secret
```

ğŸ”’ This hides the secret values.

### **View secrets with values (encoded)**

```bash
kubectl get secret app-secret -o yaml
```

---

## ğŸ§± **5. Injecting Secrets into Pods**

There are **two main methods**:

1. As **Environment Variables**
2. As **Mounted Files (Volumes)**

---

### **A. Inject as Environment Variables**

`pod.yaml` example:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app-pod
spec:
  containers:
    - name: webapp
      image: my-python-app
      envFrom:
        - secretRef:
            name: app-secret
```

âœ… This makes all key-value pairs in the `app-secret` available as environment variables inside the container.

---

### **B. Inject as a Volume**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app-pod
spec:
  containers:
    - name: webapp
      image: my-python-app
      volumeMounts:
        - name: secret-vol
          mountPath: "/etc/secrets"
  volumes:
    - name: secret-vol
      secret:
        secretName: app-secret
```

âœ… Each key in the secret becomes a **file** inside `/etc/secrets`, and the content of each file is the decoded secret value.

Example:

```
/etc/secrets/DB_HOST      â†’ mysql
/etc/secrets/DB_USER      â†’ root
/etc/secrets/DB_PASS      â†’ Passw0rd123
```

---

## ğŸ§  **6. Common Interview Questions**

| Question                                            | Answer                                                                                              |                  |
| --------------------------------------------------- | --------------------------------------------------------------------------------------------------- | ---------------- |
| What is a Kubernetes Secret?                        | An object used to store sensitive data (passwords, tokens, keys) securely in base64 encoded format. |                  |
| Whatâ€™s the difference between ConfigMap and Secret? | ConfigMaps store non-sensitive data (plain text), Secrets store sensitive data (base64 encoded).    |                  |
| How can secrets be consumed by pods?                | As environment variables or mounted files (volumes).                                                |                  |
| Are Secrets encrypted by default?                   | Stored in base64 (not encrypted); Kubernetes can use encryption-at-rest for stronger protection.    |                  |
| How to edit an existing Secret?                     | `kubectl edit secret <name>`                                                                        |                  |
| How to view decoded values of a Secret?             | `kubectl get secret <name> -o jsonpath='{.data.key}'                                                | base64 --decode` |

---

## ğŸ§° **7. Quick Commands Summary**

| Action                    | Command                                                             |                  |
| ------------------------- | ------------------------------------------------------------------- | ---------------- |
| Create secret (literal)   | `kubectl create secret generic app-secret --from-literal=key=value` |                  |
| Create secret (from file) | `kubectl create secret generic app-secret --from-file=path/to/file` |                  |
| View all secrets          | `kubectl get secrets`                                               |                  |
| Describe a secret         | `kubectl describe secret app-secret`                                |                  |
| Decode a secret value     | `echo 'bXlzcWw='                                                    | base64 --decode` |
| Delete a secret           | `kubectl delete secret app-secret`                                  |                  |

---

## ğŸ§© **Practice Tasks**

1. Create a secret named `db-secret` with keys:

   * `DB_HOST = mysql`
   * `DB_USER = admin`
   * `DB_PASS = P@ss123`

2. Verify its creation and view it in YAML.

3. Encode `DB_PASS` manually using base64.

4. Create a pod `db-pod` that injects this secret as environment variables.

5. Create another pod `db-pod-file` that mounts the secret as `/opt/db/creds`.

6. `kubectl exec` into the pod and print environment variables or list files under `/opt/db/creds`.

---
